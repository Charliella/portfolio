<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å››é‚Šå½¢å¯¦é©—å®¤ - å¹³æ¿èˆ‡é›»è…¦å„ªåŒ–ç‰ˆ</title>
    <style>
        :root {
            --bg-color: #f1f5f9;
            --primary: #4338ca;
            --accent: #ea580c;
            --success: #10b981;
            --panel-bg: #ffffff;
        }

        body {
            font-family: "PingFang TC", "Microsoft JhengHei", sans-serif;
            background-color: var(--bg-color);
            margin: 0; padding: 0;
            display: flex; flex-direction: column; align-items: center;
            overflow-x: hidden; touch-action: manipulation;
        }

        /* æ¨¡å¼åˆ‡æ›å°è¦½ */
        .nav-container {
            display: flex; gap: 10px; background: white; padding: 6px;
            border-radius: 50px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); margin: 20px 0;
        }
        .nav-btn {
            padding: 10px 25px; border: none; background: transparent;
            border-radius: 40px; font-weight: bold; color: #64748b; cursor: pointer;
        }
        .nav-btn.active { background-color: var(--primary); color: white; }

        /* ä¸»è¦ä½ˆå±€ */
        .main-container {
            display: flex; gap: 20px; width: 95%; max-width: 1200px;
            flex-direction: row; 
        }

        /* å¹³æ¿ç‰ˆæ¨£å¼èª¿æ•´ï¼šå‚ç›´æ’åˆ— */
        .tablet-mode { flex-direction: column !important; }
        .tablet-mode .control-panel { width: 100% !important; flex-direction: row; flex-wrap: wrap; }
        .tablet-mode .btn { flex: 1; min-width: 120px; padding: 20px 10px; }
        .tablet-mode .play-btn { width: 100%; padding: 25px; }

        .control-panel {
            width: 280px; background: var(--panel-bg); padding: 20px;
            border-radius: 20px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
            display: flex; flex-direction: column; gap: 12px;
            box-sizing: border-box;
        }

        .canvas-area {
            flex: 1; background: white; padding: 15px; border-radius: 20px;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); text-align: center;
        }

        canvas {
            width: 100%; height: auto; border: 2px solid #e2e8f0; border-radius: 12px;
            background: radial-gradient(#cbd5e1 1px, transparent 1px) 0 0 / 25px 25px;
            touch-action: none; cursor: crosshair;
        }

        .btn {
            padding: 14px; border: 2px solid #e2e8f0; border-radius: 12px;
            background: white; cursor: pointer; font-weight: 600; font-size: 1rem;
            transition: all 0.2s;
        }
        .btn.active { border-color: var(--primary); background: #eef2ff; color: var(--primary); }
        
        .play-btn {
            padding: 18px; border: none; border-radius: 12px; color: white;
            font-weight: bold; font-size: 1.1rem; cursor: pointer;
            background: #94a3b8; box-shadow: 0 4px 0 #64748b;
        }
        .play-btn.ready { 
            background: linear-gradient(135deg, var(--accent), #c2410c); 
            box-shadow: 0 4px 0 #9a3412;
        }
        .play-btn:active { transform: translateY(2px); box-shadow: none; }

        .hint-text {
            background: #fff7ed; padding: 12px; border-radius: 10px;
            font-size: 0.95rem; color: #9a3412; border-left: 4px solid var(--accent);
            width: 100%; box-sizing: border-box;
        }

        #formula { font-size: 1.2rem; font-weight: bold; margin-top: 15px; color: var(--primary); }
    </style>
</head>
<body>

    <div class="nav-container">
        <button id="nav-pc" class="nav-btn active" onclick="switchMode('pc')">ğŸ’» é›»è…¦æ¨¡å¼</button>
        <button id="nav-tablet" class="nav-btn" onclick="switchMode('tablet')">ğŸ“± å¹³æ¿æ¨¡å¼</button>
    </div>

    <div id="wrapper" class="main-container">
        <div class="control-panel">
            <button class="btn active" id="type-para" onclick="setShape('para')">â–± å¹³è¡Œå››é‚Šå½¢</button>
            <button class="btn" id="type-tri" onclick="setShape('tri')">â–³ ä¸‰è§’å½¢</button>
            <button class="btn" id="type-trap" onclick="setShape('trap')">â¢ æ¢¯å½¢</button>
            
            <div id="para-steps" style="display: flex; flex-direction: inherit; gap: 12px; width: 100%;">
                <div style="border-top: 1px solid #eee; margin: 5px 0;"></div>
                <button class="btn active" id="step-edit" onclick="setStep('edit')">1. èª¿æ•´å½¢ç‹€</button>
                <button class="btn" id="step-select" onclick="setStep('select')">2. é¸å–åº•é‚Š</button>
            </div>
            
            <div class="hint-text" id="hint-box">è«‹æ‹–æ›³è—é»èª¿æ•´å½¢ç‹€</div>
            
            <button id="playBtn" class="play-btn" onclick="runAnimation()">â–¶ å•Ÿå‹•å‹•ç•«</button>
            <button class="btn" style="border:none; color:#ef4444;" onclick="reset()">â†º é‡ç½®</button>
        </div>

        <div class="canvas-area">
            <canvas id="canvas" width="800" height="500"></canvas>
            <div id="formula">é¢ç© = åº• Ã— é«˜</div>
        </div>
    </div>

    <script>
        const V = {
            add: (v1, v2) => ({x: v1.x + v2.x, y: v1.y + v2.y}),
            sub: (v1, v2) => ({x: v1.x - v2.x, y: v1.y - v2.y}),
            mul: (v, s) => ({x: v.x * s, y: v.y * s}),
            dot: (v1, v2) => v1.x * v2.x + v1.y * v2.y,
            dist: (v1, v2) => Math.sqrt((v1.x-v2.x)**2 + (v1.y-v2.y)**2),
            proj: (p, a, b) => {
                const ab = V.sub(b, a);
                const t = V.dot(V.sub(p, a), ab) / (V.dot(ab, ab) || 1);
                return V.add(a, V.mul(ab, t));
            },
            inSeg: (p, a, b) => {
                const d1 = V.dot(V.sub(p, a), V.sub(b, a));
                const d2 = V.dot(V.sub(p, b), V.sub(a, b));
                return d1 >= -1 && d2 >= -1;
            }
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let shapeType = 'para'; 
        let step = 'edit';
        let points = []; 
        let selectedBaseIdx = -1;
        let isAnim = false;
        let dragIdx = -1;

        function switchMode(m) {
            document.getElementById('wrapper').classList.toggle('tablet-mode', m === 'tablet');
            document.getElementById('nav-pc').classList.toggle('active', m === 'pc');
            document.getElementById('nav-tablet').classList.toggle('active', m === 'tablet');
            setTimeout(reset, 50); // ç¢ºä¿ DOM æ¸²æŸ“å¾Œå†é‡ç¹ª
        }

        function setShape(s) {
            shapeType = s;
            document.querySelectorAll('[id^="type-"]').forEach(el => el.classList.toggle('active', el.id === 'type-'+s));
            
            // åªæœ‰å¹³è¡Œå››é‚Šå½¢é¡¯ç¤ºé¸åº•æ­¥é©Ÿ
            document.getElementById('para-steps').style.display = (s === 'para') ? 'flex' : 'none';
            
            const f = {para:'åº• Ã— é«˜', tri:'(åº• Ã— é«˜) Ã· 2', trap:'(ä¸Šåº• + ä¸‹åº•) Ã— é«˜ Ã· 2'};
            document.getElementById('formula').innerText = 'é¢ç© = ' + f[s];
            reset();
        }

        function setStep(s) {
            step = s;
            document.getElementById('step-edit').classList.toggle('active', s==='edit');
            document.getElementById('step-select').classList.toggle('active', s==='select');
            
            if(s==='edit') {
                document.getElementById('hint-box').innerHTML = "è«‹æ‹–æ›³è—é»èª¿æ•´å½¢ç‹€";
                selectedBaseIdx = -1;
                updatePlayBtn(false);
            } else {
                document.getElementById('hint-box').innerHTML = "è«‹é»æ“Šåœ–å½¢çš„ä¸€æ¢<b>é‚Š</b>ä½œç‚ºåº•";
                updatePlayBtn(false);
            }
            draw();
        }

        function reset() {
            isAnim = false;
            // ä¿®æ­£å¹³æ¿æ¨¡å¼åº§æ¨™ï¼šç¢ºä¿åœ–å½¢åœ¨å¯è¦‹ç¯„åœä¸­å¤®
            const cx = canvas.width / 4, cy = canvas.height * 0.7;
            if(shapeType === 'para') {
                points = [{x:cx, y:cy}, {x:cx+250, y:cy}, {x:cx+80, y:cy-180}];
                setStep('edit');
            } else {
                if(shapeType === 'tri') points = [{x:cx, y:cy}, {x:cx+250, y:cy}, {x:cx+125, y:cy-180}];
                else points = [{x:cx, y:cy}, {x:cx+300, y:cy}, {x:cx+220, y:cy-150}, {x:cx+80, y:cy-150}];
                selectedBaseIdx = 0; // ä¸‰è§’å½¢èˆ‡æ¢¯å½¢é è¨­åº•ç‚º 0
                updatePlayBtn(true);
                document.getElementById('hint-box').innerHTML = "æº–å‚™å°±ç·’ï¼Œè«‹å•Ÿå‹•å‹•ç•«";
            }
            draw();
        }

        function getEdges() {
            let p = points;
            if(shapeType === 'para') {
                const v = V.sub(p[1], p[0]);
                const p3 = V.add(p[2], v);
                return [[p[0],p[1]], [p[1],p3], [p3,p[2]], [p[2],p[0]]];
            } else if(shapeType === 'tri') {
                return [[p[0],p[1]], [p[1],p[2]], [p[2],p[0]]];
            } else {
                return [[p[0],p[1]], [p[1],p[2]], [p[2],p[3]], [p[3],p[0]]];
            }
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            const clientY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            // è€ƒæ…® Canvas ç¸®æ”¾æ¯”ä¾‹
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
        }

        canvas.onmousedown = canvas.ontouchstart = (e) => {
            if(isAnim) return;
            const pos = getPos(e);
            if(shapeType === 'para' && step === 'select') {
                const edges = getEdges();
                edges.forEach((edge, i) => {
                    const h = V.proj(pos, edge[0], edge[1]);
                    if(V.dist(pos, h) < 30 && V.inSeg(h, edge[0], edge[1])) validateBase(i);
                });
            } else {
                const threshold = 40; // å¢åŠ è§¸æ§æ„Ÿæ‡‰åŠå¾‘
                points.forEach((p, i) => { if(V.dist(p, pos) < threshold) dragIdx = i; });
            }
        };

        window.onmousemove = window.ontouchmove = (e) => {
            if(dragIdx === -1) return;
            const pos = getPos(e);
            if(shapeType === 'trap') {
                if(dragIdx < 2) { 
                    const dy = points[3].y - points[0].y;
                    points[dragIdx] = pos;
                    points[2].y = points[3].y = points[0].y + dy;
                } else {
                    pos.y = Math.min(pos.y, points[0].y - 30);
                    points[dragIdx] = pos;
                    points[dragIdx===2?3:2].y = pos.y;
                }
            } else {
                points[dragIdx] = pos;
            }
            draw();
            if(e.cancelable) e.preventDefault();
        };

        window.onmouseup = window.ontouchend = () => dragIdx = -1;

        function validateBase(idx) {
            const edges = getEdges();
            const base = edges[idx];
            const target = edges[2][0]; 
            const H = V.proj(target, base[0], base[1]);

            if(!V.inSeg(H, base[0], base[1])) {
                document.getElementById('hint-box').innerHTML = "âš ï¸ <b>æ­ªæ–œéåº¦ï¼</b> è«‹é¸å¦ä¸€çµ„é‚Šç•¶åº•ã€‚";
                selectedBaseIdx = -1;
                updatePlayBtn(false);
            } else {
                selectedBaseIdx = idx;
                document.getElementById('hint-box').innerHTML = "âœ… <b>é¸å®šæˆåŠŸï¼</b> å¯å•Ÿå‹•å‹•ç•«ã€‚";
                updatePlayBtn(true);
            }
            draw();
        }

        function updatePlayBtn(ready) {
            const b = document.getElementById('playBtn');
            b.disabled = !ready;
            b.classList.toggle('ready', ready);
            b.innerText = ready ? "â–¶ å•Ÿå‹•å‹•ç•«" : (shapeType==='para' ? "â–¶ è«‹å…ˆé¸åº•é‚Š" : "â–¶ å•Ÿå‹•å‹•ç•«");
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const edges = getEdges();
            const poly = edges.map(e => e[0]);

            ctx.beginPath(); ctx.moveTo(poly[0].x, poly[0].y);
            poly.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath(); ctx.fillStyle = 'rgba(67, 56, 202, 0.08)'; ctx.fill();

            edges.forEach((edge, i) => {
                ctx.beginPath(); ctx.moveTo(edge[0].x, edge[0].y); ctx.lineTo(edge[1].x, edge[1].y);
                ctx.lineWidth = (i === selectedBaseIdx) ? 6 : 2;
                ctx.strokeStyle = (i === selectedBaseIdx) ? '#10b981' : '#4338ca';
                ctx.stroke();
            });

            if(!isAnim) {
                points.forEach((p, i) => {
                    ctx.beginPath(); ctx.arc(p.x, p.y, 12, 0, Math.PI*2);
                    ctx.fillStyle = i < 2 ? '#2563eb' : '#0ea5e9';
                    ctx.fill(); ctx.strokeStyle='white'; ctx.lineWidth=2; ctx.stroke();
                });
            }
        }

        function runAnimation() {
            if(isAnim) return;
            isAnim = true;
            let progress = 0;
            const edges = getEdges();
            const idx = selectedBaseIdx;
            
            function frame() {
                progress += 0.015;
                const t = progress < 0.5 ? 2*progress*progress : 1-Math.pow(-2*progress+2, 2)/2;
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if(shapeType === 'para') {
                    let b1 = edges[idx][0], b2 = edges[idx][1];
                    let t1 = (idx===0)?edges[2][1]:(idx===1)?edges[3][1]:(idx===2)?edges[0][1]:edges[1][1];
                    let t2 = (idx===0)?edges[2][0]:(idx===1)?edges[3][0]:(idx===2)?edges[0][0]:edges[1][0];
                    const H = V.proj(t1, b1, b2);
                    const move = V.mul(V.sub(b2, b1), t);
                    drawPoly([b1, H, t1], null, '#94a3b8', true);
                    drawPoly([H, b2, t2, t1], 'rgba(67, 56, 202, 0.1)', '#4338ca');
                    const tri = [b1, H, t1].map(p => V.add(p, move));
                    drawPoly(tri, 'rgba(234, 88, 12, 0.85)', '#c2410c');
                } else {
                    const poly = edges.map(e => e[0]);
                    const mPoint = V.mul(V.add(edges[1][0], edges[1][1]), 0.5);
                    drawPoly(poly, 'rgba(67, 56, 202, 0.1)', '#4338ca');
                    ctx.save();
                    ctx.translate(mPoint.x, mPoint.y); ctx.rotate(Math.PI * t); ctx.translate(-mPoint.x, -mPoint.y);
                    drawPoly(poly, 'rgba(234, 88, 12, 0.85)', '#c2410c');
                    ctx.restore();
                }

                if(progress < 1) requestAnimationFrame(frame);
                else isAnim = false;
            }
            frame();
        }

        function drawPoly(pts, fill, stroke, dash=false) {
            ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
            pts.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            if(fill) { ctx.fillStyle = fill; ctx.fill(); }
            ctx.strokeStyle = stroke; ctx.setLineDash(dash?[5,5]:[]);
            ctx.lineWidth = 2; ctx.stroke();
        }

        window.onload = reset;
    </script>
</body>
</html>
