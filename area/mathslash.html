<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Slash - 數學之刃 (Cyberpunk 側邊欄版)</title>
    <style>
        /* 引入點陣字體和繁體中文黑體 */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Noto+Serif+TC:wght=900&display=swap');

        /* Cyberpunk Color Palette */
        :root {
            --bg-color: #0b0f14;
            --hud-bg: #1e2531;
            --hud-border: #00ffff; /* 霓虹青色 */
            --accent-color: #ff00ff; /* 霓虹洋紅 */
            --text-highlight: #fffa50; /* 電光黃 */
            --hp-color: #00ff88; /* 綠色健康 (動態調整) */
            --danger-color: #ff3333;
            --font-main: 'Press Start 2P', cursive;
            --font-title: 'Noto Serif TC', serif;
        }

        /* 核心佈局修正：使用 100% 替換 100vh，解決移動設備溢出問題 */
        html, body {
            height: 100%; 
            width: 100%;
        }

        /* 確保全螢幕且無捲軸 */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--font-main);
            touch-action: none; /* 禁止手機上的預設手勢 */
            user-select: none;
            -webkit-user-select: none;
        }

        /* 遊戲容器：使用 Flexbox 讓 HUD 和 Canvas 橫向並排 */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%; 
            background: var(--bg-color);
            display: flex;
            flex-direction: row; /* 讓內容橫向並排 (HUD + CANVAS) */
            align-items: stretch; /* 確保子元素佔滿垂直高度 */
        }

        /* HUD 介面優化 - 側邊欄佈局 */
        #doom-hud {
            /* 側邊欄固定寬度，佔據 100% 垂直高度 */
            width: clamp(120px, 15vw, 180px); /* 寬度範圍設定 */
            height: 100%; 
            min-width: 100px; /* 確保最小可讀性 */
            
            background: var(--hud-bg);
            border-right: 3px solid var(--hud-border); /* 邊界線移至右側 */
            
            /* 掃描線效果改為垂直 */
            background-image: linear-gradient(to right, rgba(0,0,0,0.5) 1px, transparent 1px);
            background-size: 4px 100%; 
            
            display: flex;
            flex-direction: column; /* 讓面板在側邊欄內垂直堆疊 */
            justify-content: space-evenly;
            align-items: center;
            z-index: 10;
            box-shadow: 0 0 15px var(--accent-color);
            padding: 10px 5px; 
            box-sizing: border-box;
            flex-shrink: 0; /* 防止 HUD 被壓縮 */
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--hud-border);
            /* 邊框霓虹光暈 */
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.4), inset 0 0 5px rgba(0, 255, 255, 0.3);
            padding: 5px;
            width: 95%; /* 佔滿側邊欄寬度 */
            flex-grow: 1; /* 讓面板在垂直方向上平均分配空間 */
            height: auto;
            max-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--accent-color);
            text-shadow: 1px 1px 0 #000;
            position: relative;
            /* 移除傾斜效果，讓側邊欄更整齊 */
            transform: none; 
            margin: 5px 0;
            min-height: 50px;
        }

        .hud-panel > * {
            transform: none; /* 移除反向傾斜 */
        }

        .hud-label {
            font-size: clamp(6px, 1vw, 10px); 
            color: #aaa;
            margin-bottom: 2px;
            text-transform: uppercase;
            text-align: center;
            line-height: 1;
        }

        .hud-value {
            font-size: clamp(8px, 1.8vw, 16px); 
            font-weight: bold;
            white-space: nowrap;
        }

        /* 目標面板特別樣式 */
        #target-panel {
            flex-grow: 1.5; /* 給予目標面板多一點垂直空間 */
            background: var(--bg-color);
            border: 3px solid var(--text-highlight);
            box-shadow: 0 0 15px var(--text-highlight), inset 0 0 10px var(--text-highlight);
            color: var(--text-highlight);
        }
        
        #target-val {
            font-family: var(--font-title);
            font-weight: 900;
            font-size: clamp(10px, 2.5vw, 20px); 
            line-height: 1.2;
            word-break: break-word;
        }

        /* 畫布佔據剩餘空間 */
        canvas {
            display: block;
            flex-grow: 1; /* 佔據所有可用的水平空間 */
            height: 100%; /* 佔據所有垂直空間 */
            width: auto;
            cursor: crosshair;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* 疊加層通用樣式 - 必須覆蓋整個 #game-container */
        .overlay-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(11, 15, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: var(--accent-color);
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.3s;
        }

        .hidden { 
            opacity: 0;
            pointer-events: none;
            display: none; 
        }

        /* 以下為介面及特效樣式，保持不變 */

        .doom-title {
            font-size: clamp(24px, 7vw, 50px);
            color: var(--text-highlight);
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px rgba(255, 0, 255, 0.5);
            margin-bottom: 30px;
            text-align: center;
            line-height: 1.5;
            font-family: var(--font-title);
            font-weight: 900;
            border-bottom: 3px dashed var(--accent-color);
            padding-bottom: 10px;
        }

        .btn {
            background: var(--accent-color);
            color: #000;
            border: 2px solid #fff;
            padding: 18px 35px;
            font-family: var(--font-main);
            font-size: clamp(10px, 2vw, 14px);
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 0 10px var(--accent-color), 0 0 20px var(--accent-color) inset;
            border-radius: 4px;
            transition: transform 0.1s, box-shadow 0.1s, background 0.1s;
            text-align: center;
            line-height: 1.3;
        }
        
        .btn:hover {
            background: #fff;
            color: var(--accent-color);
        }

        .btn:active { 
            transform: translateY(2px);
            box-shadow: 0 0 5px var(--accent-color);
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            color: #aaa;
            box-shadow: none;
        }

        .level-btns-container, .mode-btns-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 90%;
            max-width: 450px;
        }

        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--danger-color);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            mix-blend-mode: overlay;
            transition: opacity 0.1s;
        }

        .msg {
            position: absolute;
            font-family: var(--font-title);
            font-weight: 900;
            pointer-events: none;
            animation: popOut 0.8s forwards;
            z-index: 30; 
            white-space: nowrap;
        }
        
        @keyframes popOut {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -100%) scale(1); opacity: 0; }
        }

    </style>
</head>
<body>

    <div id="game-container">
        
        <div id="doom-hud">
            <div class="hud-panel">
                <div class="hud-label">STAGE</div>
                <div class="hud-value" id="stage-val">1</div>
            </div>
            
            <div class="hud-panel" style="color:var(--text-highlight);">
                <div class="hud-label">SCORE</div>
                <div class="hud-value" id="score-val">0</div>
            </div>
            
            <div class="hud-panel" id="target-panel">
                <div class="hud-label" id="target-title">TARGET PROTOCOL</div>
                <div class="hud-value" id="target-val">--</div>
            </div>
            
            <div class="hud-panel">
                <div class="hud-label">PARRY COUNT</div>
                <div class="hud-value" id="parry-val">0/3</div>
            </div>
            
            <div class="hud-panel" id="timer-panel" style="border-color: var(--hp-color); color: var(--hp-color);">
                <div class="hud-label">TIME</div>
                <div class="hud-value" id="timer-val">0.0</div>
            </div>

            <div class="hud-panel">
                <div class="hud-label">HP CORE</div>
                <div class="hud-value" id="hp-val">100%</div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>
        
        <div id="damage-overlay"></div>
        
        <div id="start-screen" class="overlay-screen">
            <div class="doom-title">MATH SLASH<br><span style="font-size:0.6em; color:#fff;">數學之刃 V2.3 (SIDEBAR)</span></div>
            <p style="color:#aaa; font-size:clamp(10px, 1.5vw, 14px); margin-bottom: 20px; text-align: center;">
                COMBINE NODES TO HIT THE TARGET VALUE.
            </p>
            <button id="start-btn" class="btn" onclick="showModeSelect()" disabled>LOADING...</button>
        </div>
        
        <div id="mode-select-screen" class="overlay-screen hidden">
            <div class="doom-title">SELECT INTERFACE MODE</div>
            <p style="color:#fff; font-size:clamp(10px, 1.5vw, 14px); margin-bottom: 20px; text-align: center;">
                請選擇您的輸入模式：
            </p>
            <div class="mode-btns-container">
                <button class="btn" onclick="setInteractionMode('CLICK')">
                    [PC] CLICK MODE (點擊)<br><span style="font-size:0.7em; color:#ffff50;">(滑鼠點擊數字節點進行選中/配對)</span>
                </button>
                <button class="btn" onclick="setInteractionMode('SLASH')">
                    [MOBILE] SLASH MODE (斬擊)<br><span style="font-size:0.7em; color:#ffff50;">(滑動手指/滑鼠拖曳進行連線斬擊)</span>
                </button>
            </div>
        </div>

        <div id="level-select-screen" class="overlay-screen hidden">
            <div class="doom-title">SELECT MISSION TYPE</div>
            <div class="level-btns-container">
                <button class="btn" onclick="startGame('SUM')">
                    [TYPE 1] SUM PROTOCOL (加法拆分)<br><span style="font-size:0.7em; color:#00ffff;">(找出兩數相加等於目標)</span>
                </button>
                <button class="btn" onclick="startGame('FACTOR')">
                    [TYPE 2] FACTOR PROTOCOL (因數分解)<br><span style="font-size:0.7em; color:#00ffff;">(找出兩數相乘等於目標)</span>
                </button>
                <button class="btn" onclick="startGame('SEQUENCE')">
                    [TYPE 3] SEQUENCE PROTOCOL (數列反算)<br><span style="font-size:0.7em; color:#00ffff;">(填補算式中的兩個缺口：運算符號與數字)</span>
                </button>
            </div>
        </div>

        <div id="ready-screen" class="overlay-screen hidden" style="background: rgba(0,0,0,0.6);">
            <div class="doom-title" style="color:var(--hp-color);">TARGET LOCKED</div>
            <div style="color:#fff; font-size:clamp(12px, 2vw, 18px); margin-bottom:20px;">INITIATE SEQUENCE?</div>
            <button class="btn" onclick="startRound()">START SLASHING</button>
        </div>

        <div id="clear-screen" class="overlay-screen hidden">
            <div class="doom-title" style="color:var(--hud-border);">PROTOCOL CLEARED</div>
            <p style="color:#fff; font-size:clamp(12px, 2vw, 16px);">TIME BONUS: <span id="clear-time" style="color:var(--hp-color);">0.00</span>s</p>
            <button class="btn" onclick="nextStage()">NEXT SECTOR</button>
        </div>

        <div id="gameover-screen" class="overlay-screen hidden">
            <div class="doom-title" style="color:var(--danger-color);">MISSION FAILED</div>
            <p style="color:#fff; font-size:clamp(12px, 2vw, 16px);">FINAL SCORE: <span id="final-score">0</span></p>
            <button class="btn" onclick="showModeSelect()">RETRY</button>
        </div>

    </div>

    <script>
        /**
         * Math Slash Cyberpunk V2.3 (Sidebar Layout Fix)
         * 修正:
         * 1. 修正 CSS 核心佈局，使用 height: 100% 解決 100vh 溢出問題。
         * 2. 將 #game-container 設置為 flex-direction: row，實現 HUD 側邊欄佈局。
         * 3. 調整 HUD 內部面板為垂直堆疊，並縮小字體以適應側邊欄。
         * 4. 調整 resize 邏輯，使其依賴 Flexbox 計算出的 Canvas 客戶端尺寸。
         */

        // --- Configuration & Constants ---
        const CONFIG = {
            BASE_WIDTH: 800,   // Reference resolution width
            BASE_HEIGHT: 600,  // Reference resolution height
            CANDIDATE_BASE_SIZE: 50,
            PARRY_NEEDED: 3,
            SWIPE_TIMEOUT_MS: 2000,
            TRAIL_LENGTH: 15,
            COLORS: {
                bg: '#0b0f14',
                trail: '#ff00ff', // Slash color (Magenta)
                trailShadow: '#00ffff',
                text: '#ffffff',
                highlight: '#fffa50',
                // 數字球的顏色設定
                part1: '#ff00ff', // First selected part color (Magenta)
                part2: '#00ffff', // Second selected part color (Cyan)
                decoys: '#444', 
                decoysStroke: '#00ffff'
            },
            // 互動模式: 由使用者選擇後設定
            INTERACTION_MODE: null
        };

        // --- Global State ---
        const state = {
            screen: 'START',
            levelType: 'SUM',
            stage: 1,
            score: 0,
            hp: 100,
            parryCount: 0,
            startTime: 0,
            targetValue: 0,
            candidates: [],
            particles: [],
            solutionPair: [], // [val1, val2] 或 [op, num]
            partialSelection: null, // First hit candidate
            partialTimer: 0,
            scaleFactor: 1,
            pointer: { x: 0, y: 0, isDown: false, trail: [] },
            // 數列反算特有狀態
            sequenceFound: { op: false, num: false } 
        };

        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const hud = document.getElementById('doom-hud');
        const ui = {
            stage: document.getElementById('stage-val'),
            score: document.getElementById('score-val'),
            targetVal: document.getElementById('target-val'),
            targetTitle: document.getElementById('target-title'),
            parry: document.getElementById('parry-val'),
            timer: document.getElementById('timer-val'),
            hp: document.getElementById('hp-val'),
            screens: {
                start: document.getElementById('start-screen'),
                mode: document.getElementById('mode-select-screen'),
                level: document.getElementById('level-select-screen'),
                ready: document.getElementById('ready-screen'),
                clear: document.getElementById('clear-screen'),
                gameover: document.getElementById('gameover-screen')
            }
        };

        // --- Background Asset ---
        const bgImage = new Image();
        bgImage.src = 'https://placehold.co/1024x768/000/00ffff?text=CYBERNETIC+GRID';
        bgImage.onload = () => {
            document.getElementById('start-btn').disabled = false;
            document.getElementById('start-btn').innerText = "START MISSION";
        };

        // --- Resizing & Responsive Logic (已修正) ---
        function resize() {
            // DPI Scaling (Retina support)
            const dpr = window.devicePixelRatio || 1;
            
            // 取得 Flexbox 佈局後，Canvas 實際佔據的 CSS 尺寸
            const canvasCssWidth = canvas.clientWidth;
            const canvasCssHeight = canvas.clientHeight;
            
            // 設置內部畫布的繪圖緩衝區尺寸
            canvas.width = canvasCssWidth * dpr;
            canvas.height = canvasCssHeight * dpr;
            
            // 歸一化坐標系
            ctx.scale(dpr, dpr);
            
            // 根據新的畫布尺寸重新計算縮放因子
            // 此處使用 Canvas 的尺寸，因為 Flexbox 已經處理了 HUD 的寬度
            state.scaleFactor = Math.min(canvasCssWidth / CONFIG.BASE_WIDTH, canvasCssHeight / CONFIG.BASE_HEIGHT) * 1.2; 
            if (canvasCssWidth < 600) state.scaleFactor *= 1.2;
            
            updateHpDisplay(state.hp);
        }
        window.addEventListener('resize', resize);
        resize(); 


        // --- Input Handling (保持不變) ---

        function getCanvasPos(evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function triggerHitCheck(x, y) {
            if (state.screen !== 'PLAYING') return;
            const hitCandidate = getHitCandidate({ x, y });
            if (hitCandidate) {
                processHit(hitCandidate);
            }
        }
        
        function handlePointerDown(e) {
            if (state.screen !== 'PLAYING') return;
            if (e.type === 'mousedown') e.preventDefault(); 
            
            const pos = getCanvasPos(e);
            state.pointer.x = pos.x;
            state.pointer.y = pos.y;
            state.pointer.isDown = true;
            state.pointer.trail = [{x: pos.x, y: pos.y}];
            
            if (CONFIG.INTERACTION_MODE === 'CLICK') {
                triggerHitCheck(pos.x, pos.y);
            }
        }

        function handlePointerMove(e) {
            if (!state.pointer.isDown || state.screen !== 'PLAYING') return;
            e.preventDefault(); 
            
            const pos = getCanvasPos(e);
            
            state.pointer.trail.push({x: pos.x, y: pos.y});
            if (state.pointer.trail.length > CONFIG.TRAIL_LENGTH) {
                state.pointer.trail.shift();
            }

            if (CONFIG.INTERACTION_MODE === 'SLASH') {
                checkLineCollision(state.pointer.x, state.pointer.y, pos.x, pos.y);
            }

            state.pointer.x = pos.x;
            state.pointer.y = pos.y;
        }

        function handlePointerUp(e) {
            state.pointer.isDown = false;
            state.pointer.trail = [];
        }

        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        window.addEventListener('mouseup', handlePointerUp);

        canvas.addEventListener('touchstart', handlePointerDown, {passive: false});
        canvas.addEventListener('touchmove', handlePointerMove, {passive: false});
        window.addEventListener('touchend', handlePointerUp);


        // --- Game Logic Classes (保持不變) ---
        
        class Candidate {
            constructor(val, solutionKey, type='number') {
                this.text = String(val);
                this.solutionKey = solutionKey; // 'P1', 'P2', 'DECOY'
                this.dataType = type; // 'number', 'operator', or 'mix'
                
                this.radius = (CONFIG.CANDIDATE_BASE_SIZE / 2) * state.scaleFactor;
                
                const w = canvas.width / (window.devicePixelRatio || 1);
                const h = canvas.height / (window.devicePixelRatio || 1);
                const margin = this.radius * 2;
                
                // Position finding logic...
                let attempts = 0;
                let safe = false;
                while(!safe && attempts < 50) {
                    this.x = margin + Math.random() * (w - margin * 2);
                    this.y = margin + Math.random() * (h - margin * 2);
                    
                    safe = true;
                    for (let c of state.candidates) {
                        const dist = Math.hypot(this.x - c.x, this.y - c.y);
                        if (dist < (this.radius + c.radius) * 1.5) { 
                            safe = false;
                            break;
                        }
                    }
                    attempts++;
                }

                // Random velocity (scaled)
                const speed = (0.5 + Math.random() * 1.0) * state.scaleFactor;
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                this.highlighted = false;
                this.selected = false;
                this.scaleAnim = 1;
            }

            update() {
                const w = canvas.width / (window.devicePixelRatio || 1);
                const h = canvas.height / (window.devicePixelRatio || 1);

                this.x += this.vx;
                this.y += this.vy;

                // Boundary bounce
                if (this.x < this.radius) { this.x = this.radius; this.vx *= -1; }
                if (this.x > w - this.radius) { this.x = w - this.radius; this.vx *= -1; }
                if (this.y < this.radius) { this.y = this.radius; this.vy *= -1; }
                if (this.y > h - this.radius) { this.y = h - this.radius; this.vy *= -1; }

                if (this.selected) {
                    this.scaleAnim = 1 + Math.sin(Date.now() / 100) * 0.1;
                } else {
                    this.scaleAnim = 1;
                }
            }

            draw() {
                const r = this.radius * this.scaleAnim;
                
                ctx.save();
                ctx.translate(this.x, this.y);

                // Cyberpunk Glow Effect
                ctx.shadowBlur = this.highlighted || this.selected ? 30 : 10;
                const glowColor = this.selected ? (this.solutionKey === 'P1' ? CONFIG.COLORS.part1 : CONFIG.COLORS.part2) : CONFIG.COLORS.decoysStroke;
                ctx.shadowColor = glowColor;

                // Fill
                ctx.fillStyle = this.selected ? 'rgba(0,0,0,0.8)' : CONFIG.COLORS.decoys;
                
                // Border Color based on selection part
                let strokeColor = CONFIG.COLORS.decoysStroke;
                if (this.selected) {
                    strokeColor = this.solutionKey === 'P1' ? CONFIG.COLORS.part1 : CONFIG.COLORS.part2;
                } else if (this.highlighted) {
                    strokeColor = CONFIG.COLORS.highlight;
                }

                ctx.lineWidth = 4 * state.scaleFactor;
                ctx.strokeStyle = strokeColor;

                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Text
                ctx.shadowBlur = 0;
                ctx.fillStyle = this.selected ? '#fff' : strokeColor; 
                ctx.font = `${Math.floor(20 * state.scaleFactor)}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, 0, 2 * state.scaleFactor);

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 * state.scaleFactor;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = 0.03;
                this.size = (Math.random() * 4 + 2) * state.scaleFactor;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // --- Screen Management (保持不變) ---

        function switchScreen(screenName) {
            state.screen = screenName;
            Object.values(ui.screens).forEach(el => el.classList.add('hidden'));
            
            if (screenName === 'START') ui.screens.start.classList.remove('hidden');
            if (screenName === 'MODE_SELECT') ui.screens.mode.classList.remove('hidden');
            if (screenName === 'LEVEL_SELECT') ui.screens.level.classList.remove('hidden');
            if (screenName === 'READY') ui.screens.ready.classList.remove('hidden');
            if (screenName === 'CLEARED') ui.screens.clear.classList.remove('hidden');
            if (screenName === 'GAMEOVER') ui.screens.gameover.classList.remove('hidden');
        }

        function showModeSelect() { 
            switchScreen('MODE_SELECT'); 
        }

        function setInteractionMode(mode) {
            CONFIG.INTERACTION_MODE = mode;
            showLevelSelect();
        }

        function showLevelSelect() { 
            switchScreen('LEVEL_SELECT'); 
        }


        function startGame(type) {
            state.levelType = type;
            state.stage = 1;
            state.score = 0;
            state.hp = 100;
            ui.score.innerText = '0';
            updateHpDisplay(100);
            setupStage();
        }

        function setupStage() {
            state.parryCount = 0;
            state.partialSelection = null;
            state.candidates = [];
            state.particles = [];
            state.sequenceFound = { op: false, num: false }; // Reset sequence state
            
            ui.stage.innerText = state.stage;
            ui.parry.innerText = `0/${CONFIG.PARRY_NEEDED}`;
            ui.timer.innerText = "0.0";
            
            // Generate Data
            const data = generateLevelData(state.levelType, state.stage);
            state.targetValue = data.target;
            state.solutionPair = data.pair;
            
            // Setup UI Display
            ui.targetTitle.innerText = state.levelType;
            ui.targetVal.innerHTML = formatTargetValue(state.targetValue, state.levelType);

            // Spawn Candidates
            // P1 and P2 are always the first two candidates
            state.candidates.push(new Candidate(data.pair[0], 'P1', data.type));
            state.candidates.push(new Candidate(data.pair[1], 'P2', data.type));
            // Decoys
            data.decoys.forEach(decoy => {
                state.candidates.push(new Candidate(decoy, 'DECOY', data.type));
            });

            switchScreen('READY');
        }

        function formatTargetValue(target, type) {
            if (type === 'SEQUENCE') {
                const parts = target.split(' ');
                // 替換問號，紅問號 for Op, 藍問號 for Num
                parts[1] = `<span style="color:${CONFIG.COLORS.part1};">${state.sequenceFound.op ? parts[1] : '?'}</span>`;
                parts[2] = `<span style="color:${CONFIG.COLORS.part2};">${state.sequenceFound.num ? parts[2] : '?'}</span>`;
                return parts.join(' ');
            }
            return target;
        }

        function startRound() {
            switchScreen('PLAYING');
            state.startTime = performance.now();
        }

        function nextStage() {
            state.stage++;
            setupStage();
        }

        function updateHpDisplay(hp) {
            state.hp = hp;
            ui.hp.innerText = state.hp + "%";
            
            let color = 'var(--hp-color)'; // Default: Green
            if (hp <= 50) color = '#ffaa00'; // Yellow/Orange
            if (hp <= 20) color = 'var(--danger-color)'; // Red
            
            gameContainer.style.setProperty('--hp-color', color);
            ui.hp.style.color = color;
        }

        // --- Collision & Interaction (保持不變) ---

        function getHitCandidate({x, y}) {
            for (let c of state.candidates) {
                const dx = x - c.x;
                const dy = y - c.y;
                if (dx*dx + dy*dy < c.radius * c.radius) {
                    return c;
                }
            }
            return null;
        }

        function checkLineCollision(x1, y1, x2, y2) {
            for (let c of state.candidates) {
                if (c.selected && c === state.partialSelection) continue;

                const dist = pointToSegmentDistance(c.x, c.y, x1, y1, x2, y2);
                if (dist < c.radius) {
                    processHit(c);
                    return; 
                }
            }
        }

        function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
            const l2 = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);
            if (l2 === 0) return Math.hypot(px-x1, py-y1);
            let t = ((px-x1)*(x2-x1) + (py-y1)*(y2-y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(px - (x1 + t * (x2-x1)), py - (y1 + t * (y2-y1)));
        }

        function processHit(candidate) {
            if (candidate.highlighted) return;
            
            candidate.highlighted = true;
            setTimeout(() => candidate.highlighted = false, 150);
            
            spawnParticles(candidate.x, candidate.y, CONFIG.COLORS.highlight);

            if (state.levelType === 'SEQUENCE') {
                handleSequenceHit(candidate);
                return;
            }

            // --- SUM/FACTOR Logic ---
            const isSolutionPart = (candidate.solutionKey === 'P1' || candidate.solutionKey === 'P2');
            
            if (!isSolutionPart) {
                handleFail("WRONG NODE!", 20);
                return;
            }

            // Deselection
            if (state.partialSelection === candidate) {
                state.partialSelection.selected = false;
                state.partialSelection = null;
                showFloatMsg(candidate.x, candidate.y, "CANCELLED", false);
                return;
            }

            if (state.partialSelection === null) {
                // First Hit
                state.partialSelection = candidate;
                candidate.selected = true;
                state.partialTimer = Date.now();
                showFloatMsg(candidate.x, candidate.y, "NODE LOCKED", true);
            } else {
                // Second Hit - Check if it's the remaining part
                const otherKey = state.partialSelection.solutionKey === 'P1' ? 'P2' : 'P1';
                if (candidate.solutionKey === otherKey) {
                    // Success!
                    scoreSuccess(candidate.x, candidate.y);
                } else {
                    // Two correct nodes but same key (impossible with current generation) or already used key
                    handleFail("PROTOCOL MISMATCH!", 15);
                }
            }
        }
        
        function handleSequenceHit(candidate) {
            const isOp = ['+', '-', 'x', '/'].includes(candidate.text);
            const isNum = !isOp;

            let solved = false;
            
            if (candidate.solutionKey === 'P1' && isOp && !state.sequenceFound.op) {
                // Correct Operator
                state.sequenceFound.op = true;
                solved = true;
            } else if (candidate.solutionKey === 'P2' && isNum && !state.sequenceFound.num) {
                // Correct Number
                state.sequenceFound.num = true;
                solved = true;
            } else if (candidate.solutionKey === 'DECOY') {
                // Decoy hit
                handleFail("DATA CORRUPTION!", 15);
                return;
            } else if (candidate.solutionKey === 'P1' && isOp && state.sequenceFound.op) {
                // Already found operator
                showFloatMsg(candidate.x, candidate.y, "ALREADY RESOLVED", false);
                return;
            } else if (candidate.solutionKey === 'P2' && isNum && state.sequenceFound.num) {
                // Already found number
                showFloatMsg(candidate.x, candidate.y, "ALREADY RESOLVED", false);
                return;
            } else {
                // Hitting wrong type (e.g., hitting operator P1 with a number)
                handleFail("TYPE MISMATCH!", 15);
                return;
            }

            if (solved) {
                // Successfully found one part
                showFloatMsg(candidate.x, candidate.y, "RESOLVED!", true);
                
                // Remove the candidate node
                state.candidates = state.candidates.filter(c => c !== candidate);
                
                // Update target display
                ui.targetVal.innerHTML = formatTargetValue(state.targetValue, state.levelType);
                
                // Check for completion
                if (state.sequenceFound.op && state.sequenceFound.num) {
                    scoreSuccess(candidate.x, candidate.y);
                }
            }
        }

        function scoreSuccess(x, y) {
            state.score += 100 + Math.floor(state.hp / 10);
            ui.score.innerText = state.score;
            state.parryCount++;
            ui.parry.innerText = `${state.parryCount}/${CONFIG.PARRY_NEEDED}`;
            
            showFloatMsg(x, y, state.levelType === 'SEQUENCE' ? "COMPLETED!" : "PARRY!", true);
            spawnParticles(x, y, '#00ff00');
            
            if(state.partialSelection) state.partialSelection.selected = false;
            state.partialSelection = null;

            if (state.parryCount >= CONFIG.PARRY_NEEDED) {
                handleClear();
            } else {
                setTimeout(respawnCandidates, 500);
            }
        }

        function handleFail(msg, damage) {
            const newHp = state.hp - damage;
            updateHpDisplay(newHp);
            
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = 0.8;
            setTimeout(() => overlay.style.opacity = 0, 150);
            
            showFloatMsg(canvas.width/2, canvas.height/2, msg, false);

            if(state.partialSelection) state.partialSelection.selected = false;
            state.partialSelection = null;

            if (newHp <= 0) {
                switchScreen('GAMEOVER');
                document.getElementById('final-score').innerText = state.score;
            }
        }

        function handleClear() {
            state.score += 500;
            const time = (performance.now() - state.startTime) / 1000;
            document.getElementById('clear-time').innerText = time.toFixed(2);
            switchScreen('CLEARED');
        }

        function respawnCandidates() {
            const count = state.candidates.length;
            const data = generateLevelData(state.levelType, state.stage);
            
            state.targetValue = data.target;
            state.solutionPair = data.pair;
            
            ui.targetVal.innerHTML = formatTargetValue(state.targetValue, state.levelType);

            state.candidates = [];
            state.sequenceFound = { op: false, num: false }; 

            state.candidates.push(new Candidate(data.pair[0], 'P1', data.type));
            state.candidates.push(new Candidate(data.pair[1], 'P2', data.type));
            data.decoys.forEach(decoy => {
                state.candidates.push(new Candidate(decoy, 'DECOY', data.type));
            });
        }

        function showFloatMsg(x, y, text, good) {
            const el = document.createElement('div');
            el.className = 'msg';
            el.innerText = text;
            
            const canvasRect = canvas.getBoundingClientRect();
            el.style.left = (x + canvasRect.left) + 'px';
            el.style.top = (y + canvasRect.top) + 'px';
            
            el.style.color = good ? 'var(--hp-color)' : 'var(--danger-color)';
            el.style.textShadow = good ? '0 0 5px var(--hp-color)' : '0 0 5px var(--danger-color)';
            el.style.fontSize = (20 * state.scaleFactor) + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function spawnParticles(x, y, color) {
            for(let i=0; i<10; i++) {
                state.particles.push(new Particle(x, y, color));
            }
        }

        // --- Data Generation (保持不變) ---

        function generateLevelData(type, stage) {
            const baseCount = Math.min(8 + Math.floor(stage / 2), 12);
            let decoys = [];

            if (type === 'SUM') {
                const base = Math.pow(10, Math.floor(Math.random()*2)+1); 
                const target = Math.floor(Math.random()*8 + 2) * base;
                let p1 = Math.floor(Math.random() * target * 0.8) + (target*0.1);
                p1 = Math.floor(p1);
                let p2 = target - p1;
                
                while(decoys.length < baseCount - 2) {
                    const decoy = Math.floor(Math.random()*target * 1.5);
                    if (decoy !== p1 && decoy !== p2 && decoy > 0) decoys.push(decoy);
                }
                return { target: target, pair: [p1, p2], decoys: decoys, type: 'number' };
            }
            else if (type === 'FACTOR') {
                let p1 = Math.floor(Math.random()*15) + 2; 
                let p2 = Math.floor(Math.random()*15) + 2;
                let target = p1 * p2;
                
                while(decoys.length < baseCount - 2) {
                    const decoy = Math.floor(Math.random()*target*0.8) + 1; 
                    if (target % decoy !== 0 && decoy !== p1 && decoy !== p2 && decoy > 1) { 
                        decoys.push(decoy);
                    }
                }
                return { target: target, pair: [p1, p2], decoys: decoys, type: 'number' };
            }
            else {
                // SEQUENCE
                const ops = ['+', '-', 'x', '/'];
                const op = ops[Math.floor(Math.random()*ops.length)];
                
                let n1, n2, res;
                let valid = false;
                
                while(!valid) {
                    n1 = Math.floor(Math.random()*15) + 5; 
                    n2 = Math.floor(Math.random()*15) + 1;

                    if(op === '+') res = n1 + n2;
                    if(op === '-') res = n1 - n2;
                    if(op === 'x') res = n1 * n2;
                    
                    if (op === '/') {
                        n1 = n2 * (Math.floor(Math.random()*8) + 2); 
                        res = n1 / n2;
                    }

                    if (res > 0 && Number.isInteger(res) && n1 > 0 && n2 > 0) {
                        valid = true;
                    }
                }
                
                const displayText = `${n1} ? ${res} = ${res}`;
                
                const solutionOp = op;
                const solutionNum = n2;
                
                const decoyOps = ops.filter(o => o !== solutionOp).slice(0, 2);
                const decoyNums = [];
                while(decoyNums.length < 2) {
                    const decoy = Math.floor(Math.random()*20) + 1;
                    if (decoy !== solutionNum) decoyNums.push(decoy);
                }

                const allDecoys = [...decoyOps, ...decoyNums];
                
                return { target: displayText, pair: [solutionOp, solutionNum], decoys: allDecoys, type: 'mix' };
            }
        }


        // --- Main Loop (保持不變) ---
        function loop() {
            requestAnimationFrame(loop);
            
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            ctx.fillStyle = CONFIG.COLORS.bg;
            ctx.fillRect(0, 0, w, h);
            
            // Draw background grid effect
            ctx.globalAlpha = 0.2;
            const gridSize = 40 * state.scaleFactor;
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 0.5;
            for(let x = 0; x < w; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for(let y = 0; y < h; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0;

            if (state.screen === 'PLAYING') {
                ui.timer.innerText = ((performance.now() - state.startTime)/1000).toFixed(1);

                state.candidates.forEach(c => {
                    c.update();
                    c.draw();
                });

                if (state.partialSelection && state.levelType !== 'SEQUENCE') {
                    if (Date.now() - state.partialTimer > CONFIG.SWIPE_TIMEOUT_MS) {
                        state.partialSelection.selected = false;
                        state.partialSelection = null;
                        handleFail("DATA LINK EXPIRED!", 10); 
                    }
                }
            }

            state.particles = state.particles.filter(p => p.life > 0);
            state.particles.forEach(p => { p.update(); p.draw(); });

            // Draw Trail (Slash Effect)
            if (state.pointer.isDown && state.pointer.trail.length > 1 && CONFIG.INTERACTION_MODE === 'SLASH') {
                ctx.beginPath();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = 6 * state.scaleFactor;
                ctx.strokeStyle = CONFIG.COLORS.trail;
                ctx.shadowBlur = 15;
                ctx.shadowColor = CONFIG.COLORS.trailShadow;
                
                const trail = state.pointer.trail;
                ctx.moveTo(trail[0].x, trail[0].y);
                
                // Quadratic bezier for smooth curve
                for (let i = 1; i < trail.length - 1; i++) {
                    const xc = (trail[i].x + trail[i+1].x) / 2;
                    const yc = (trail[i].y + trail[i+1].y) / 2;
                    ctx.quadraticCurveTo(trail[i].x, trail[i].y, xc, yc);
                }
                if(trail.length > 2) ctx.lineTo(trail[trail.length-1].x, trail[trail.length-1].y);
                
                ctx.stroke();
                ctx.shadowBlur = 0; 
            }
        }

        // Initialize
        loop();

    </script>
</body>
</html>
